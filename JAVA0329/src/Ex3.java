
public class Ex3 {

	public static void main(String[] args) {
		/*
		 * 비트 단위 논리연산(&, |, ~, ^)
		 * - 일반 논리연산자의 경우 boolean 타입에 대한 논리 연산을 수행하지만,
		 *   비트 단위 논리연산자의 경우 수치데이터(정수)에 대한 2진수 연산을 수행
		 * - AND 연산자(&) : 두 비트가 모두 1일 때만 1, 하나라도 0이면 0
		 * - OR 연산자(|) : 두 비트가 중 하나라도 1이면 1, 두 비트모두 0이면 0
		 * - XOR 연산자(^) : 두 비트가 서로 다르면 1, 같으면 0
		 * - NOR 연산자(~) : 비트를 모두 반전시킴 (0 -> 1, 1 -> 0)
		 */
		
		int num1 = 10, num2 = 7;
		
		System.out.printf("%d & %d = %d\n", num1 , num2 , num1 &num2);
		/*
		 * 10 & 7 =2
		 * 2진수로 변환하여 AND연산
		 * 00001010(10)
		 * 00000111( 7)
		 * -------------AND연산(둘 다 1이면 1, 하나라도 0이면0)
		 * 00000010( 2)
		 * 
		 */
		
		System.out.printf("%d | %d = %d\n", num1 , num2 , num1 |num2);		
		/*
		 * 10 | 7 =15
		 * 2진수로 변환하여 OR연산
		 * 00001010(10)
		 * 00000111( 7)
		 * -------------OR연산(하나라도 1이면 1, 둘다 0이면0)
		 * 00001111(15)
		 * 
		 */
		System.out.printf("%d ^ %d = %d\n", num1 , num2 , num1 ^ num2);		
		/*
		 * 10 | 7 =15
		 * 2진수로 변환하여 XOR연산
		 * 00001010(10)
		 * 00000111( 7)
		 * -------------XOR연산(서로 다르면 1, 같으면0)
		 * 00001111(13)
		 * 
		 */
		
		System.out.printf("~ %d = %d\n", num1 , ~num1);		
		/*
		 * ~10 = -11
		 * 2진수로 변환하여 NOT연산
		 * 00001010(10)
		 * -------------NOT연산(비트 반전. 0 -> 1, 1 -> 0)
		 * 11110101(-11) NOT 연산 결과값이 -11이 된다.
		 * => 이 때, 맨 앞자리 부호비트가 1이므로 음수로 취급되어
		 *    2의 보수 표현법으로 계산된 결과가 -11이다.
		 *    이 수를 다시 2의 보수 방식으로 계산하면 절대값 방식으로 변환됨
		 *    
		 * 1 1110101(-11)
		 * --------------- 2의 보수 방식으로 변환(부호는 그대로 유지)
		 * 1 0001010     => 1의 보수 변환(비트를 반전)
		 *        +1     => 2의 보수 = 1의 보수 변환결과에 +1
		 * ---------------
		 * 1 0001011     => 2의 보수 변환(절대값 방식으로 되돌린 결과값)
		 */
		
		System.out.printf("~ %d = %d\n", 1 , ~1);
		/*
		 *  ~1 = -2
		 *  00000001(1)
		 *  ------------- NOT 연산
		 *  11111110(-2)
		 *  
		 *  1 1111110
		 *  ------------ 1의 보수
		 *  1 0000001
		 *         +1
		 *  ------------ 2의 보수
		 *  1 0000010       
		 */
	}

}
